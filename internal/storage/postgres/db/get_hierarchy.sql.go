// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: get_hierarchy.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getHierarchy = `-- name: GetHierarchy :many
WITH RECURSIVE r(id, name, parent_id, level) AS
        (SELECT tr.id, tr.name, tr.parent_id, 1
        FROM nodes tl
        LEFT JOIN nodes tr 
        ON tl.id = tr.id
        WHERE tl.id = $1
        UNION ALL
        SELECT t.id, t.name, t.parent_id, level+1
        FROM nodes t, r
        WHERE t.id = r.parent_id )
        SELECT id, name, parent_id, ROW_NUMBER() OVER (ORDER BY level DESC) AS level, info.address, info.phone_number, info.contact_person FROM r AS hierarchy 
        LEFT JOIN info 
        ON hierarchy.id = info.node_id
`

type GetHierarchyRow struct {
	ID            pgtype.Int4 `json:"id"`
	Name          pgtype.Text `json:"name"`
	ParentID      pgtype.Int4 `json:"parent_id"`
	Level         int64       `json:"level"`
	Address       pgtype.Text `json:"address"`
	PhoneNumber   pgtype.Text `json:"phone_number"`
	ContactPerson pgtype.Text `json:"contact_person"`
}

func (q *Queries) GetHierarchy(ctx context.Context, id int32) ([]GetHierarchyRow, error) {
	rows, err := q.db.Query(ctx, getHierarchy, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHierarchyRow{}
	for rows.Next() {
		var i GetHierarchyRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentID,
			&i.Level,
			&i.Address,
			&i.PhoneNumber,
			&i.ContactPerson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
